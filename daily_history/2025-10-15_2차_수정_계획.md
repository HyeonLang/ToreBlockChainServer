nft item 의 인게임 복귀 구조를 burn이 아니라 락업으로 수정


1. 데이터베이스(DB) 테이블 정보 정리
   아이템을 NFT화하기 전/후로 분리하고, NFT 종류를 정의하는 테이블을 포함하여 세 가지 핵심 테이블이 필요합니다.

A. NFT 정의 테이블 (NFT_Definition) - 정적 속성
역할: 모든 NFT 종류의 공통 정의 및 운영 정보 관리.

주요 필드:
| 컬럼명 | 데이터 타입 | 설명 |
| :--- | :--- | :--- |
| nft_contract_address | VARCHAR | Primary Key. 해당 NFT 종류를 발행한 스마트 컨트랙트 주소. |
| item_code | VARCHAR | 아이템 종류를 식별하는 인게임 코드 (예: SWORD_RARE_001). |
| base_api_endpoint | VARCHAR | Dynamic Metadata API의 기본 주소 (예: https://gameapi.com/metadata/). |
| vault_contract_address | VARCHAR | 이 NFT를 보관하는 Vault 컨트랙트 주소. |
| base_attack | INTEGER | 아이템의 기본 공격력 (정적 데이터). |

B. NFT 아이템 인스턴스 테이블 (NFT_Item_Instance) - 동적 속성
역할: 민팅이 완료된 개별 NFT 아이템의 실시간 동적 상태 관리.

주요 필드:
| 컬럼명 | 데이터 타입 | 설명 |
| :--- | :--- | :--- |
| token_id | VARCHAR | Primary Key. 블록체인 상의 고유 ID. |
| nft_contract_address | VARCHAR | Foreign Key. 어떤 컨트랙트의 NFT인지 연결. |
| owner_wallet_address | VARCHAR | 현재 블록체인 상의 소유 지갑 주소. |
| current_enhancement_level | INTEGER | 동적 데이터. 현재 강화 레벨. |
| current_durability | INTEGER | 동적 데이터. 현재 내구도. |
| user_id | INTEGER | Foreign Key. 인게임에서 이 NFT를 사용 중인 유저 ID (Vault에 있을 경우에만 유효). |
| lock_status | VARCHAR | 현재 상태 (WALLET, VAULT, LISTED). |

C. (선택적) 인게임 아이템 인스턴스 테이블 (InGame_Item_Instance)
역할: 아직 NFT로 민팅되지 않은 일반 인게임 아이템의 상태 관리.

주요 필드: instance_id (PK), item_code, user_id, current_enhancement_level 등.

2. Dynamic Metadata JSON 형식 샘플
   게임 서버의 Dynamic Metadata API가 token_id를 기반으로 DB를 조회하여 실시간으로 생성 및 반환하는 JSON 형식입니다.

JSON

{
"name": "Legendary Frostmourne Blade +10", // 이름에 동적 데이터 반영
"description": "북쪽에서 발견된 서리 마법이 깃든 전설적인 검.",
"image": "ipfs://Qmb8Vd1A...9z4xY/frostmourne.png", // IPFS 주소 (정적)

"attributes": [
// 정적 속성 (DB의 NFT_Definition에서 옴)
{ "trait_type": "Rarity", "value": "Mythic" },
{ "trait_type": "Base Attack", "value": 120, "display_type": "number" },

    // 동적 속성 (DB의 NFT_Item_Instance에서 옴)
    { "trait_type": "Enhancement Level", "value": 10, "display_type": "number" },
    { "trait_type": "Current Durability", "value": 98, "display_type": "number" },
    { "trait_type": "Current Lock Status", "value": "VAULT" }, // 현재 인게임 락업 상태

    // 계산된 최종 값
    { "trait_type": "Total Attack Power", "value": 1000, "display_type": "number" }
]
}
3. Vault Contract를 활용한 NFT 운영 과정 (자세히)
   A. 민팅 (Minting) 과정
   이 과정은 NFT를 블록체인에 처음 기록하고 DB에 초기 인스턴스를 만드는 과정입니다.

아이템 획득 (In-Game): 플레이어가 인게임에서 '철검'을 획득하고 DB의 InGame_Item_Instance 테이블에 기록됩니다.

민팅 요청 (User): 플레이어가 이 아이템을 NFT화하겠다고 게임 서버에 요청합니다.

온체인 발행 (Server): 게임 서버는 NFT 컨트랙트를 호출하여 mintItem(플레이어_지갑_주소) 함수를 실행합니다.

결과: 새로운 token_id가 생성되고, 소유권은 플레이어의 지갑으로 설정됩니다.

DB 업데이트:

InGame_Item_Instance에서 아이템 레코드를 삭제합니다.

NFT_Item_Instance 테이블에 새 token_id, owner_wallet_address(플레이어 지갑), lock_status: WALLET으로 새 레코드를 삽입합니다.
~~~~
B. 인게임 복귀 (기술적 락업 / Deposit) 과정
NFT를 블록체인에서 개인 지갑으로 가져와 인게임에서 사용 가능하도록 잠그는(Lock-up) 과정입니다.

입금 요청 (User): 플레이어가 지갑에서 게임의 Vault Contract 주소로 NFT 전송(Transfer)을 요청합니다.

온체인 전송: 플레이어의 지갑에서 NFT 컨트랙트의 transferFrom 함수를 호출하여 NFT를 Vault Contract 주소로 보냅니다.

이벤트 감지 (Server): 게임 서버의 블록체인 이벤트 리스너가 Vault Contract로의 Transfer 이벤트를 실시간으로 감지합니다.

DB 락업:

서버는 해당 token_id를 확인하고, NFT_Item_Instance 테이블의 owner_wallet_address를 Vault Contract 주소로 업데이트합니다.

lock_status를 **VAULT**로 변경하고, user_id 필드에 플레이어의 인게임 ID를 기록하여 인게임 사용 권한을 부여합니다.

C. 인게임 이탈 / 재민팅 (Withdrawal) 과정
아이템을 인게임에서 잠금 해제하여 다시 개인 지갑으로 전송하는 과정입니다.

출금 요청 (User): 플레이어가 인게임에서 NFT를 지갑으로 출금하겠다고 요청합니다.

권한 확인 (Server): 서버는 DB에서 token_id의 lock_status가 VAULT이고, 요청 유저의 user_id와 일치하는지 확인합니다.

온체인 전송 (Server): 게임 서버가 Vault Contract에 서명된 트랜잭션을 전송하여, 해당 NFT를 Vault Contract → 플레이어의 개인 지갑 주소로 다시 전송(withdrawNFT 함수 등)하도록 지시합니다.

DB 해제:

서버는 블록체인에서 전송 완료 이벤트를 감지합니다.

NFT_Item_Instance 테이블의 owner_wallet_address를 플레이어의 지갑 주소로 업데이트합니다.

lock_status를 **WALLET**으로 변경하고, user_id 필드를 NULL로 설정합니다.