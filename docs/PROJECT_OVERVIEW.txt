[프로젝트 개요]
이 프로젝트는 블록체인 스마트 컨트랙트(솔리디티, Solidity)와 웹 서버(익스프레스, Express)를 함께 사용하는 템플릿입니다.
- 하드햇(Hardhat) + 타입스크립트(TypeScript) + 익스프레스(Express)
- ERC-721(NFT) 표준을 사용하는 스마트 컨트랙트(GameItem)
- Avalanche 네트워크(Fuji 테스트넷 / 메인넷)에 배포하는 스크립트
- NFT 민팅/삭제(burn) JSON REST API 제공

이 문서는 파이썬만 조금 아는 대학교 초년생을 대상으로, 모든 파일과 폴더의 의미를 빠짐없이 친절하게 설명합니다.


[용어 간단 정리]
- 블록체인: 거래(또는 데이터) 기록을 모두가 공유/검증하는 분산 원장 기술
- 스마트 컨트랙트: 블록체인 위에서 실행되는 프로그램(여기서는 Solidity로 작성)
- NFT(ERC-721): 대체 불가능 토큰, 각각 고유한 ID를 가진 토큰 표준
- 하드햇(Hardhat): 솔리디티를 컴파일/테스트/배포하는 개발 툴
- 익스프레스(Express): Node.js 서버 프레임워크(HTTP API 구현에 사용)
- 타입스크립트: 자바스크립트에 타입을 추가한 언어(서버 코드의 안전성 향상)


[폴더/파일 구조와 역할]
1) contracts/
   - GameItem.sol
     - 이더리움(또는 호환 네트워크)용 솔리디티 스마트 컨트랙트입니다.
     - OpenZeppelin 라이브러리의 ERC721URIStorage + Ownable을 상속합니다.
       - ERC721URIStorage: 각 토큰에 메타데이터 주소(tokenURI)를 저장하는 기능 제공
       - Ownable: 컨트랙트에 “소유자” 개념 추가(민팅/삭제 권한 통제)
     - 핵심 상태/함수:
       - 상태: _nextTokenId (다음 발행될 토큰 ID를 위한 카운터)
       - constructor(name, symbol, initialOwner): NFT 컬렉션 이름/심볼/초기 소유자 설정
       - mint(to, tokenURI): onlyOwner만 호출 가능. 새로운 토큰 ID를 하나 증가시켜 민팅하고, 메타데이터 주소를 저장
       - burn(tokenId): onlyOwner만 호출 가능. 토큰을 영구 삭제
       - nextTokenId(): 다음에 발행될 토큰 ID 미리보기
     - 메타데이터(tokenURI): 일반적으로 IPFS나 HTTPS URL을 사용하여 이미지/속성 JSON을 가리킵니다.

2) scripts/
   - deploy.ts
     - 하드햇을 사용해 GameItem 컨트랙트를 네트워크에 배포하는 스크립트입니다.
     - 환경변수 NFT_NAME/NFT_SYMBOL(선택)을 읽어 이름/심볼 설정 가능(없으면 기본값 GameItem/GMI)
     - 배포자(지갑)는 .env의 PRIVATE_KEY로 지정된 계정입니다.
     - 배포 후 컨트랙트 주소를 출력합니다. 이 주소를 서버에서 사용할 CONTRACT_ADDRESS로 설정해야 합니다.

3) hardhat.config.cjs
   - 하드햇 설정 파일입니다(ESM 프로젝트 호환을 위해 .cjs 사용).
   - 솔리디티 버전(0.8.26), 최적화 설정, 디렉터리(contracts, artifacts 등),
     네트워크 설정(Fuji, Avalanche)이 정의되어 있습니다.
   - 네트워크 계정은 PRIVATE_KEY로 지정됩니다(배열 1개 계정).

4) src/
   - app.ts
     - Express 서버의 진입점(메인 파일).
     - JSON 파싱 미들웨어 설정, /health 엔드포인트, /api/nft 라우터 등록, 포트 리스닝 등을 담당합니다.

   - routes/
     - nft.ts
       - /api/nft 주소로 들어오는 요청을 컨트롤러에 연결합니다.
       - GET /api/nft/address → 현재 사용 중인 컨트랙트 주소 반환
       - POST /api/nft/mint → NFT 민팅
       - POST /api/nft/burn → NFT 삭제

   - controllers/
     - nftController.ts
       - contractAddressController: 환경변수 CONTRACT_ADDRESS를 반환
       - mintNftController: 입력으로 to(받는 지갑 주소), tokenURI(메타데이터 URL) 받고 컨트랙트 mint 호출
       - burnNftController: 입력으로 tokenId 받고 컨트랙트 burn 호출
       - 각 함수는 실패 시 에러를 JSON으로 반환합니다.

   - utils/
     - contract.ts
       - 블록체인 연결 유틸리티.
       - getProvider(): RPC_URL(또는 FUJI_RPC_URL)로 JSON-RPC Provider 생성
       - getWallet(): PRIVATE_KEY로 서명 가능한 지갑(Wallet) 생성
       - getContract(): CONTRACT_ADDRESS와 ABI(컴파일 산출물)로 컨트랙트 인스턴스 생성
       - 컨트롤러가 이 유틸을 통해 실제 블록체인에 트랜잭션을 보냅니다.

   - middleware/
     - errorHandler.ts
       - 에러를 JSON 형태로 응답하는 Express 미들웨어(현재 app.ts에서는 비활성화 상태지만 필요시 추가 가능)

5) package.json
   - 프로젝트 메타 정보 및 스크립트 정의
   - 주요 스크립트:
     - build: TypeScript 전체 빌드(출력은 dist/)
     - dev: tsx로 개발 서버 실행(자동 재시작)
     - start: dist/app.js 실행(프로덕션 용)
     - compile: Hardhat 컴파일(컨트랙트 ABI/바이트코드 생성)
     - deploy:fuji / deploy:avalanche: 지정 네트워크로 배포
   - 의존성:
     - 서버: express, dotenv
     - 블록체인: hardhat, ethers, @nomicfoundation/hardhat-toolbox
     - 타입/도구: typescript, tsx 등

6) tsconfig.json
   - TypeScript 컴파일러 설정입니다.
   - src, scripts, hardhat.config.cjs를 대상으로 컴파일/타입체크합니다.

7) README.md
   - 빠른 시작 가이드, 구조 개요, 명령어, API 안내를 간단히 정리한 문서입니다.

8) .env.example
   - 환경변수 예시 파일입니다. 실제 실행 시 .env를 만들어 값을 채워야 합니다.
   - 주요 항목:
     - PORT: 서버 포트(기본 3000)
     - PRIVATE_KEY: 배포/트랜잭션에 사용할 지갑 개인키(절대 공개 금지)
     - FUJI_RPC_URL / AVALANCHE_RPC_URL: 네트워크 RPC 주소
     - RPC_URL: 서버가 기본으로 사용할 RPC(보통 FUJI_RPC_URL과 동일하게 둠)
     - CONTRACT_ADDRESS: 배포된 GameItem 컨트랙트 주소


[설치와 실행]
1) 의존성 설치
   - 터미널에서 프로젝트 루트에서 실행
     npm install

2) 컨트랙트 컴파일
   - 하드햇으로 솔리디티 컴파일(ABI/바이트코드 생성)
     npx hardhat compile

3) 네트워크에 배포(Fuji 테스트넷 예시)
   - .env 설정: PRIVATE_KEY, FUJI_RPC_URL 입력
   - 배포 실행
     npx hardhat run scripts/deploy.ts --network fuji
   - 터미널에 출력되는 컨트랙트 주소를 복사해서 .env의 CONTRACT_ADDRESS에 입력

4) 서버 실행
   - 개발 모드(코드 변경 감지)
     npm run dev
   - 브라우저/도구에서 헬스체크 확인
     http://localhost:3000/health → {"ok": true}


[API 사용법]
1) 현재 컨트랙트 주소 확인
   - GET http://localhost:3000/api/nft/address
   - 응답 예: { "address": "0x1234..." }

2) NFT 민팅
   - POST http://localhost:3000/api/nft/mint
   - JSON Body 예:
     { "to": "0x수신자지갑주소", "tokenURI": "https://.../metadata.json" }
   - 성공 시 트랜잭션 해시 반환: { "txHash": "0x..." }
   - 주의: 컨트랙트 소유자(Ownable의 owner)만 민팅 가능. 서버의 PRIVATE_KEY 계정이 owner여야 합니다.

3) NFT 삭제(burn)
   - POST http://localhost:3000/api/nft/burn
   - JSON Body 예:
     { "tokenId": 1 }
   - 성공 시 트랜잭션 해시 반환: { "txHash": "0x..." }
   - 주의: owner만 삭제 가능


[블록체인 연동 흐름(한눈에 이해)]
- 사용자가 서버에 요청(민팅/삭제)을 보냄 →
- 컨트롤러(nftController)가 유효성 검사 후 →
- utils/contract.ts에서 Wallet + Contract 인스턴스를 만들고 →
- 컨트랙트 함수 호출(mint/burn) 트랜잭션 생성 →
- 네트워크에 브로드캐스트 → 블록에 포함되면 트랜잭션 해시/영수증 반환 →
- 서버가 결과를 JSON으로 응답


[보안/운영 주의사항]
- PRIVATE_KEY 절대 공개 금지, 깃에 올리지 않기(.env는 .gitignore에 포함 권장)
- 민팅/삭제 권한은 컨트랙트 owner에게만 있음 → 서버의 지갑이 owner인지 반드시 확인
- RPC 제공자를 신뢰할 수 있는 서비스로 설정(공용 RPC는 지연/제한 가능)
- 프로덕션에서는 HTTPS, 프록시/로드밸런서, 로깅/모니터링 고려
- 요청 유효성 검증 강화(주소 형식, tokenURI 길이/형식 등)
- Rate limiting, CORS 정책, API 키/토큰 기반 인증 고려


[자주 겪는 오류와 해결]
- Error: PRIVATE_KEY is required → .env에 PRIVATE_KEY 미설정. 값 추가 필요
- Error: CONTRACT_ADDRESS is required → 배포 후 주소를 .env에 넣지 않음. 주소 입력
- insufficient funds for gas → 지갑에 가스비(AVAX)가 부족. 테스트넷 수량 충전 필요
- invalid address → to가 올바른 0x주소인지 확인
- Mint/Burn 권한 오류 → 서버 지갑이 owner인지 확인(배포 시 owner가 누구인지 체크)


[앞으로의 개발 방향(Roadmap 제안)]
1) 메타데이터/이미지 호스팅
   - IPFS(예: Pinata, web3.storage) 업로드 유틸 추가 → tokenURI 자동 생성
   - 메타데이터 스키마 정의(name, description, image, attributes)

2) 인증/권한 관리
   - 관리자 전용 API 보호(JWT, API Key, 또는 지갑 서명 검증)
   - 민팅 대행 시 화이트리스트나 역할(Role) 기반 제어

3) DB 연동
   - 발행/삭제 이력, 소유자, 트랜잭션 해시 등을 DB에 기록(PostgreSQL/SQLite)
   - 인덱싱/조회용 API(페이지네이션, 필터링)

4) 이벤트 인덱싱
   - 컨트랙트 이벤트(Transfer 등) 구독/백필로 오프체인 DB에 동기화
   - 재시도/오프셋 관리, 장애 복구 로직

5) 테스트/품질
   - 하드햇 테스트(단위/통합) 작성
   - ESLint/Prettier 규칙 정비, 타입 강화
   - CI/CD 파이프라인(GitHub Actions)로 컴파일/테스트/배포 자동화

6) 성능/안정성
   - 요청 큐/재시도, RPC 장애 대비(백업 RPC), 타임아웃 설정
   - Rate limiting, 캐시, 헬스체크 확대(/ready, /metrics 등)

7) 프런트엔드 연동
   - 간단한 대시보드(민팅 폼, 토큰 조회, 트랜잭션 상태) → 서버 API와 상호작용

8) 멀티체인/업그레이드
   - 추가 체인 지원(Polygon, BSC 등)
   - 업그레이어블 컨트랙트(투표/관리 정책 포함) 검토


[마무리]
이 템플릿은 “스마트 컨트랙트 배포 + 서버 API로 민팅/삭제”의 최소 기능을 안전하게 시작할 수 있는 뼈대입니다.
.env 설정을 정확히 하고, 배포 주소(CONTRACT_ADDRESS)를 서버에 반영하면 즉시 동작합니다.
위 Roadmap을 따라 확장하면 프로덕션 수준의 NFT 서비스로 발전시킬 수 있습니다.
