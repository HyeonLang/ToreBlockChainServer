# NFT ë¸”ë¡ì²´ì¸ í”„ë¡œì íŠ¸ ì™„ì „ ê°€ì´ë“œ - 13í¸: ì‹œìŠ¤í…œ í†µí•© ë° ìµœì í™”

## ğŸ“š ëª©ì°¨
1. [ì „ì²´ ì‹œìŠ¤í…œ í†µí•©](#ì „ì²´-ì‹œìŠ¤í…œ-í†µí•©)
2. [ì»¨íŠ¸ë™íŠ¸ ê°„ ì—°ë™](#ì»¨íŠ¸ë™íŠ¸-ê°„-ì—°ë™)
3. [ë°±ì—”ë“œ ì‹œìŠ¤í…œ í†µí•©](#ë°±ì—”ë“œ-ì‹œìŠ¤í…œ-í†µí•©)
4. [í”„ë¡ íŠ¸ì—”ë“œ í†µí•©](#í”„ë¡ íŠ¸ì—”ë“œ-í†µí•©)
5. [ë°ì´í„° íë¦„ ìµœì í™”](#ë°ì´í„°-íë¦„-ìµœì í™”)
6. [ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
7. [ë³´ì•ˆ ê°•í™”](#ë³´ì•ˆ-ê°•í™”)
8. [ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…](#ëª¨ë‹ˆí„°ë§-ë°-ë¡œê¹…)
9. [ë°°í¬ ë° ìš´ì˜](#ë°°í¬-ë°-ìš´ì˜)
10. [í™•ì¥ì„± ê³ ë ¤ì‚¬í•­](#í™•ì¥ì„±-ê³ ë ¤ì‚¬í•­)

---

## ğŸ— ì „ì²´ ì‹œìŠ¤í…œ í†µí•©

### í†µí•© ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ì›¹ ë¸Œë¼ìš°ì € (í”„ë¡ íŠ¸ì—”ë“œ)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NFT ê´€ë¦¬ â”‚ TORE í† í° â”‚ ê±°ë˜ì†Œ â”‚ ì§€ê°‘ ì—°ê²° â”‚ ê±°ë˜ ë‚´ì—­ â”‚ í†µê³„ ëŒ€ì‹œë³´ë“œ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Express ì„œë²„ (ë°±ì—”ë“œ)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ NFT API â”‚ TORE API â”‚ ê±°ë˜ì†Œ API â”‚ ì¸ì¦ â”‚ ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… â”‚ ì—ëŸ¬ ì²˜ë¦¬ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Avalanche ë¸”ë¡ì²´ì¸ ë„¤íŠ¸ì›Œí¬                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GameItem â”‚ ToreToken â”‚ ToreExchange â”‚ ì´ë²¤íŠ¸ ë¡œê·¸ â”‚ íŠ¸ëœì­ì…˜ ë‚´ì—­ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì‹œìŠ¤í…œ êµ¬ì„± ìš”ì†Œ

**í”„ë¡ íŠ¸ì—”ë“œ:**
- **NFT ê´€ë¦¬**: ìƒì„±, ì „ì†¡, ì‚­ì œ, ì¡°íšŒ
- **TORE í† í°**: ì”ì•¡ ì¡°íšŒ, ì „ì†¡, ë‚´ì—­ ì¡°íšŒ
- **ê±°ë˜ì†Œ**: ê±°ë˜ ìƒì„±, êµ¬ë§¤, ì·¨ì†Œ
- **ì§€ê°‘ ì—°ë™**: MetaMask ì—°ê²° ë° ìë™ ì£¼ì†Œ ì…ë ¥
- **í†µí•© ëŒ€ì‹œë³´ë“œ**: ëª¨ë“  ê¸°ëŠ¥ì„ í•œ ê³³ì—ì„œ ê´€ë¦¬

**ë°±ì—”ë“œ:**
- **API ì„œë²„**: RESTful API ì œê³µ
- **ì¸ì¦ ì‹œìŠ¤í…œ**: JWT + API í‚¤ í•˜ì´ë¸Œë¦¬ë“œ ì¸ì¦
- **ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…**: API í˜¸ì¶œ ì œí•œ
- **ì—ëŸ¬ ì²˜ë¦¬**: í†µí•© ì—ëŸ¬ ê´€ë¦¬
- **ë¡œê¹…**: ìƒì„¸í•œ ë¡œê·¸ ê¸°ë¡

**ë¸”ë¡ì²´ì¸:**
- **GameItem**: ERC721 NFT ì»¨íŠ¸ë™íŠ¸
- **ToreToken**: ERC20 í† í° ì»¨íŠ¸ë™íŠ¸
- **ToreExchange**: NFT-TORE ê±°ë˜ì†Œ ì»¨íŠ¸ë™íŠ¸
- **ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ**: ëª¨ë“  ê±°ë˜ ë‚´ì—­ ê¸°ë¡

---

## ğŸ”— ì»¨íŠ¸ë™íŠ¸ ê°„ ì—°ë™

### ì»¨íŠ¸ë™íŠ¸ ì˜ì¡´ì„±

```
ToreExchange
â”œâ”€â”€ GameItem (NFT ì»¨íŠ¸ë™íŠ¸)
â””â”€â”€ ToreToken (í† í° ì»¨íŠ¸ë™íŠ¸)

ToreToken
â”œâ”€â”€ GameItem (ê²Œì„ í†µí•©)
â””â”€â”€ ToreExchange (ê±°ë˜ì†Œ ì—°ë™)
```

### ì—°ë™ ì„¤ì •

```typescript
// ê±°ë˜ì†Œ ë°°í¬ í›„ ì—°ë™ ì„¤ì •
async function setupContractIntegration() {
  const toreToken = await ethers.getContractAt("ToreToken", TORE_TOKEN_ADDRESS);
  const exchange = await ethers.getContractAt("ToreExchange", EXCHANGE_ADDRESS);
  
  // ê±°ë˜ì†Œë¥¼ TORE í† í°ì— ì¶”ê°€
  await toreToken.addExchangeContract(EXCHANGE_ADDRESS);
  console.log("Exchange contract added to TORE token");
  
  // ê²Œì„ ì»¨íŠ¸ë™íŠ¸ë¥¼ TORE í† í°ì— ì¶”ê°€ (ì˜ˆì‹œ)
  if (GAME_CONTRACT_ADDRESS) {
    await toreToken.addGameContract(GAME_CONTRACT_ADDRESS);
    console.log("Game contract added to TORE token");
  }
  
  // ê²Œì„ ë§¤ë‹ˆì €ë¥¼ TORE í† í°ì— ì¶”ê°€ (ì˜ˆì‹œ)
  if (GAME_MANAGER_ADDRESS) {
    await toreToken.addGameManager(GAME_MANAGER_ADDRESS);
    console.log("Game manager added to TORE token");
  }
}
```

### ê¶Œí•œ ê´€ë¦¬

```solidity
// ToreToken.sol - ê±°ë˜ì†Œ ì „ì†¡ ê¶Œí•œ
function exchangeTransfer(address from, address to, uint256 amount) external {
    require(exchangeContracts[msg.sender], "ToreToken: Only authorized exchange contracts");
    _transfer(from, to, amount);
}

// ToreToken.sol - ê²Œì„ ë³´ìƒ ì§€ê¸‰ ê¶Œí•œ
function distributeGameReward(address player, uint256 amount) external {
    require(
        gameContracts[msg.sender] || gameManagers[msg.sender] || msg.sender == owner(),
        "ToreToken: Only authorized game contracts or managers"
    );
    _mint(player, amount);
}
```

---

## ğŸ–¥ ë°±ì—”ë“œ ì‹œìŠ¤í…œ í†µí•©

### í†µí•© ì•± êµ¬ì¡°

```typescript
// src/app.ts
import express from "express";
import dotenv from "dotenv";

// ë¼ìš°í„° ì„í¬íŠ¸
import nftRouter from "./routes/nft";
import toreTokenRouter from "./routes/toreToken";
import exchangeRouter from "./routes/exchange";
import authRouter from "./routes/auth";
import v1Router from "./routes/v1";

// ë¯¸ë“¤ì›¨ì–´ ì„í¬íŠ¸
import { errorHandler } from "./middleware/errorHandler";
import { jwtOrApiKeyAuth } from "./middleware/auth";
import { rateLimit } from "./middleware/rateLimit";

dotenv.config();

const app = express();

// ê¸°ë³¸ ë¯¸ë“¤ì›¨ì–´
app.use(express.json());
app.use(express.static("public"));

// ì¸ì¦ì´ í•„ìš”í•˜ì§€ ì•Šì€ ë¼ìš°íŠ¸
app.use("/api/auth", authRouter);

// ì¸ì¦ì´ í•„ìš”í•œ ë¼ìš°íŠ¸
app.use("/api/nft", jwtOrApiKeyAuth, nftRouter);
app.use("/api/tore", jwtOrApiKeyAuth, toreTokenRouter);
app.use("/api/exchange", jwtOrApiKeyAuth, exchangeRouter);
app.use("/v1", jwtOrApiKeyAuth, v1Router);

// ì—ëŸ¬ í•¸ë“¤ëŸ¬
app.use(errorHandler);

export default app;
```

### í†µí•© ì»¨íŠ¸ë¡¤ëŸ¬

```typescript
// src/controllers/integratedController.ts
export async function getSystemStats(req: Request, res: Response) {
  try {
    const nftContract = await getContract();
    const toreTokenContract = await getToreTokenContract();
    const exchangeContract = await getExchangeContract();
    
    // NFT í†µê³„
    const totalNfts = await nftContract.nextTokenId() - 1;
    
    // TORE í† í° í†µê³„
    const totalSupply = await toreTokenContract.totalSupply();
    const tokenInfo = await toreTokenContract.name();
    
    // ê±°ë˜ì†Œ í†µê³„
    const totalTrades = await exchangeContract.getTotalTrades();
    const activeTrades = await exchangeContract.getActiveTradeCount();
    
    res.json({
      success: true,
      data: {
        nft: {
          totalNfts: totalNfts.toString(),
          contractAddress: process.env.CONTRACT_ADDRESS
        },
        toreToken: {
          name: tokenInfo,
          totalSupply: ethers.formatUnits(totalSupply, 18),
          contractAddress: process.env.TORE_TOKEN_ADDRESS
        },
        exchange: {
          totalTrades: totalTrades.toString(),
          activeTrades: activeTrades.toString(),
          contractAddress: process.env.TORE_EXCHANGE_ADDRESS
        }
      }
    });
  } catch (error) {
    console.error('[Integrated Controller] Get system stats error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get system statistics'
    });
  }
}
```

### í†µí•© ìœ í‹¸ë¦¬í‹°

```typescript
// src/utils/integration.ts
export async function getWalletOverview(address: string) {
  try {
    const nftContract = await getContract();
    const toreTokenContract = await getToreTokenContract();
    
    // NFT ì •ë³´
    const nftBalance = await nftContract.balanceOf(address);
    const nfts = [];
    for (let i = 1; i <= nftBalance; i++) {
      try {
        const owner = await nftContract.ownerOf(i);
        if (owner.toLowerCase() === address.toLowerCase()) {
          const tokenURI = await nftContract.tokenURI(i);
          nfts.push({ tokenId: i, tokenURI });
        }
      } catch (error) {
        // í† í°ì´ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì†Œê°ë¨
        continue;
      }
    }
    
    // TORE í† í° ì •ë³´
    const toreBalance = await toreTokenContract.balanceOf(address);
    const toreBalanceFormatted = ethers.formatUnits(toreBalance, 18);
    
    return {
      address,
      nfts: {
        count: nfts.length,
        items: nfts
      },
      toreToken: {
        balance: toreBalanceFormatted,
        symbol: 'TORE'
      }
    };
  } catch (error) {
    console.error('[Integration] Failed to get wallet overview:', error);
    throw error;
  }
}
```

---

## ğŸŒ í”„ë¡ íŠ¸ì—”ë“œ í†µí•©

### í†µí•© ëŒ€ì‹œë³´ë“œ

```html
<!-- í†µí•© ëŒ€ì‹œë³´ë“œ íƒ­ -->
<div id="dashboardTab" class="tab-content">
    <div class="dashboard-grid">
        <!-- NFT ì„¹ì…˜ -->
        <div class="dashboard-section">
            <h3>ğŸ¨ NFT ê´€ë¦¬</h3>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">ë³´ìœ  NFT</span>
                    <span class="stat-value" id="nftCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ì´ NFT</span>
                    <span class="stat-value" id="totalNfts">0</span>
                </div>
            </div>
            <div class="actions">
                <button onclick="switchTab('create')" class="btn">NFT ìƒì„±</button>
                <button onclick="switchTab('wallet')" class="btn">NFT ì¡°íšŒ</button>
            </div>
        </div>
        
        <!-- TORE í† í° ì„¹ì…˜ -->
        <div class="dashboard-section">
            <h3>ğŸª™ TORE í† í°</h3>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">ë³´ìœ ëŸ‰</span>
                    <span class="stat-value" id="toreBalance">0 TORE</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ì´ ê³µê¸‰ëŸ‰</span>
                    <span class="stat-value" id="totalSupply">0 TORE</span>
                </div>
            </div>
            <div class="actions">
                <button onclick="switchTab('toreBalance')" class="btn">ì”ì•¡ ì¡°íšŒ</button>
                <button onclick="switchTab('toreTransfer')" class="btn">í† í° ì „ì†¡</button>
            </div>
        </div>
        
        <!-- ê±°ë˜ì†Œ ì„¹ì…˜ -->
        <div class="dashboard-section">
            <h3>ğŸª ê±°ë˜ì†Œ</h3>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">í™œì„± ê±°ë˜</span>
                    <span class="stat-value" id="activeTrades">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ì´ ê±°ë˜</span>
                    <span class="stat-value" id="totalTrades">0</span>
                </div>
            </div>
            <div class="actions">
                <button onclick="loadActiveTrades()" class="btn">ê±°ë˜ ëª©ë¡</button>
                <button onclick="switchTab('createTrade')" class="btn">ê±°ë˜ ìƒì„±</button>
            </div>
        </div>
    </div>
</div>
```

### í†µí•© JavaScript

```javascript
// public/js/integration.js
let systemStats = null;

async function loadSystemStats() {
  try {
    const response = await fetch('/api/system/stats');
    const data = await response.json();
    
    if (data.success) {
      systemStats = data.data;
      updateDashboard();
    } else {
      throw new Error(data.error || 'ì‹œìŠ¤í…œ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨');
    }
  } catch (error) {
    console.error('ì‹œìŠ¤í…œ í†µê³„ ì¡°íšŒ ì˜¤ë¥˜:', error);
    showStatus(`ì‹œìŠ¤í…œ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`, 'error');
  }
}

function updateDashboard() {
  if (!systemStats) return;
  
  // NFT í†µê³„ ì—…ë°ì´íŠ¸
  document.getElementById('totalNfts').textContent = systemStats.nft.totalNfts;
  
  // TORE í† í° í†µê³„ ì—…ë°ì´íŠ¸
  document.getElementById('totalSupply').textContent = systemStats.toreToken.totalSupply + ' TORE';
  
  // ê±°ë˜ì†Œ í†µê³„ ì—…ë°ì´íŠ¸
  document.getElementById('totalTrades').textContent = systemStats.exchange.totalTrades;
  document.getElementById('activeTrades').textContent = systemStats.exchange.activeTrades;
}

async function loadWalletOverview() {
  if (!currentAccount) {
    showStatus('ì§€ê°‘ì„ ë¨¼ì € ì—°ê²°í•´ì£¼ì„¸ìš”', 'error');
    return;
  }
  
  try {
    const response = await fetch(`/api/wallet/overview/${currentAccount}`);
    const data = await response.json();
    
    if (data.success) {
      updateWalletStats(data.data);
    } else {
      throw new Error(data.error || 'ì§€ê°‘ ê°œìš” ì¡°íšŒ ì‹¤íŒ¨');
    }
  } catch (error) {
    console.error('ì§€ê°‘ ê°œìš” ì¡°íšŒ ì˜¤ë¥˜:', error);
    showStatus(`ì§€ê°‘ ê°œìš” ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`, 'error');
  }
}

function updateWalletStats(walletData) {
  // NFT ê°œìˆ˜ ì—…ë°ì´íŠ¸
  document.getElementById('nftCount').textContent = walletData.nfts.count;
  
  // TORE ì”ì•¡ ì—…ë°ì´íŠ¸
  document.getElementById('toreBalance').textContent = walletData.toreToken.balance + ' TORE';
}
```

---

## ğŸ“Š ë°ì´í„° íë¦„ ìµœì í™”

### ìºì‹± ì „ëµ

```typescript
// src/utils/cache.ts
class MemoryCache {
  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  
  set(key: string, data: any, ttl: number = 300000) { // 5ë¶„ ê¸°ë³¸ TTL
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  
  get(key: string): any | null {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear() {
    this.cache.clear();
  }
}

export const cache = new MemoryCache();
```

### ìºì‹œ ì ìš©

```typescript
// src/controllers/toreTokenController.ts
export async function getBalance(req: Request, res: Response) {
  try {
    const { address } = req.params;
    
    // ìºì‹œ í™•ì¸
    const cacheKey = `balance:${address}`;
    const cachedBalance = cache.get(cacheKey);
    
    if (cachedBalance) {
      return res.json({
        success: true,
        data: cachedBalance,
        cached: true
      });
    }
    
    // ë¸”ë¡ì²´ì¸ì—ì„œ ì¡°íšŒ
    const balance = await getTokenBalance(address);
    const result = {
      address,
      balance,
      symbol: 'TORE'
    };
    
    // ìºì‹œì— ì €ì¥ (1ë¶„ TTL)
    cache.set(cacheKey, result, 60000);
    
    res.json({
      success: true,
      data: result,
      cached: false
    });
  } catch (error) {
    console.error('[ToreToken Controller] Get balance error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get token balance'
    });
  }
}
```

### ë°°ì¹˜ ì²˜ë¦¬

```typescript
// src/utils/batchProcessor.ts
export class BatchProcessor {
  private queue: Array<{ id: string; data: any; resolve: Function; reject: Function }> = [];
  private processing = false;
  
  async add<T>(id: string, data: any): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push({ id, data, resolve, reject });
      this.process();
    });
  }
  
  private async process() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;
    
    while (this.queue.length > 0) {
      const batch = this.queue.splice(0, 10); // 10ê°œì”© ë°°ì¹˜ ì²˜ë¦¬
      
      try {
        const results = await Promise.allSettled(
          batch.map(item => this.processItem(item))
        );
        
        results.forEach((result, index) => {
          const item = batch[index];
          if (result.status === 'fulfilled') {
            item.resolve(result.value);
          } else {
            item.reject(result.reason);
          }
        });
      } catch (error) {
        batch.forEach(item => item.reject(error));
      }
    }
    
    this.processing = false;
  }
  
  private async processItem(item: any) {
    // ì‹¤ì œ ì²˜ë¦¬ ë¡œì§
    return await this.executeItem(item.data);
  }
  
  private async executeItem(data: any) {
    // êµ¬í˜„ í•„ìš”
    return data;
  }
}

export const batchProcessor = new BatchProcessor();
```

---

## âš¡ ì„±ëŠ¥ ìµœì í™”

### ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™” (í–¥í›„ í™•ì¥)

```typescript
// src/database/optimization.ts
export class DatabaseOptimizer {
  // ì¸ë±ìŠ¤ ìµœì í™”
  async createIndexes() {
    // ìì£¼ ì¡°íšŒë˜ëŠ” í•„ë“œì— ì¸ë±ìŠ¤ ìƒì„±
    await this.createIndex('transfers', 'from');
    await this.createIndex('transfers', 'to');
    await this.createIndex('transfers', 'tokenId');
    await this.createIndex('transfers', 'blockNumber');
  }
  
  // ì¿¼ë¦¬ ìµœì í™”
  async getOptimizedTransfers(address: string, limit: number = 100) {
    // ë³µí•© ì¸ë±ìŠ¤ í™œìš©
    return await this.query(`
      SELECT * FROM transfers 
      WHERE (from = ? OR to = ?) 
      ORDER BY blockNumber DESC 
      LIMIT ?
    `, [address, address, limit]);
  }
  
  // ì—°ê²° í’€ ìµœì í™”
  async optimizeConnectionPool() {
    // ì—°ê²° í’€ ì„¤ì • ìµœì í™”
    this.pool = {
      min: 5,
      max: 20,
      acquireTimeoutMillis: 30000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      idleTimeoutMillis: 30000,
      reapIntervalMillis: 1000,
      createRetryIntervalMillis: 200
    };
  }
}
```

### API ìµœì í™”

```typescript
// src/middleware/optimization.ts
export const compression = (req: Request, res: Response, next: NextFunction) => {
  // ì‘ë‹µ ì••ì¶•
  const originalSend = res.send;
  res.send = function(data) {
    if (typeof data === 'string' && data.length > 1024) {
      // í° ì‘ë‹µì€ ì••ì¶•
      res.setHeader('Content-Encoding', 'gzip');
    }
    return originalSend.call(this, data);
  };
  next();
};

export const requestOptimization = (req: Request, res: Response, next: NextFunction) => {
  // ìš”ì²­ ìµœì í™”
  if (req.method === 'GET') {
    // GET ìš”ì²­ ìºì‹œ í—¤ë” ì„¤ì •
    res.setHeader('Cache-Control', 'public, max-age=300'); // 5ë¶„ ìºì‹œ
  }
  next();
};
```

---

## ğŸ”’ ë³´ì•ˆ ê°•í™”

### ì…ë ¥ ê²€ì¦ ê°•í™”

```typescript
// src/middleware/validation.ts
import Joi from 'joi';

export const validateAddress = (req: Request, res: Response, next: NextFunction) => {
  const addressSchema = Joi.string().pattern(/^0x[a-fA-F0-9]{40}$/);
  
  if (req.params.address) {
    const { error } = addressSchema.validate(req.params.address);
    if (error) {
      return res.status(400).json({
        success: false,
        error: 'Invalid address format'
      });
    }
  }
  next();
};

export const validateAmount = (req: Request, res: Response, next: NextFunction) => {
  const amountSchema = Joi.number().positive().max(1000000); // ìµœëŒ€ 100ë§Œ
  
  if (req.body.amount) {
    const { error } = amountSchema.validate(parseFloat(req.body.amount));
    if (error) {
      return res.status(400).json({
        success: false,
        error: 'Invalid amount'
      });
    }
  }
  next();
};
```

### ë³´ì•ˆ í—¤ë”

```typescript
// src/middleware/security.ts
export const securityHeaders = (req: Request, res: Response, next: NextFunction) => {
  // ë³´ì•ˆ í—¤ë” ì„¤ì •
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Content-Security-Policy', "default-src 'self'");
  
  next();
};
```

### ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… ê°•í™”

```typescript
// src/middleware/rateLimit.ts
export const strictRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15ë¶„
  max: 100, // ìµœëŒ€ 100 ìš”ì²­
  message: {
    success: false,
    error: 'Too many requests, please try again later'
  },
  standardHeaders: true,
  legacyHeaders: false
});

export const apiRateLimit = rateLimit({
  windowMs: 60 * 1000, // 1ë¶„
  max: 60, // ìµœëŒ€ 60 ìš”ì²­
  message: {
    success: false,
    error: 'API rate limit exceeded'
  }
});
```

---

## ğŸ“ˆ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

### í†µí•© ë¡œê¹… ì‹œìŠ¤í…œ

```typescript
// src/utils/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'tore-blockchain-server' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

export default logger;
```

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```typescript
// src/middleware/monitoring.ts
export const performanceMonitoring = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    const logData = {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: duration,
      timestamp: new Date().toISOString(),
      userAgent: req.get('User-Agent'),
      ip: req.ip
    };
    
    logger.info('Request completed', logData);
    
    // ëŠë¦° ìš”ì²­ ê²½ê³ 
    if (duration > 5000) {
      logger.warn('Slow request detected', logData);
    }
  });
  
  next();
};
```

### ì—ëŸ¬ ì¶”ì 

```typescript
// src/middleware/errorTracking.ts
export const errorTracking = (error: Error, req: Request, res: Response, next: NextFunction) => {
  const errorData = {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    timestamp: new Date().toISOString()
  };
  
  logger.error('Application error', errorData);
  
  // ì™¸ë¶€ ì—ëŸ¬ ì¶”ì  ì„œë¹„ìŠ¤ë¡œ ì „ì†¡ (ì˜ˆ: Sentry)
  // Sentry.captureException(error);
  
  next(error);
};
```

---

## ğŸš€ ë°°í¬ ë° ìš´ì˜

### í”„ë¡œë•ì…˜ ë°°í¬

```bash
# í”„ë¡œë•ì…˜ ë¹Œë“œ
npm run build

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
cp .env.example .env.production

# PM2ë¡œ í”„ë¡œë•ì…˜ ì‹¤í–‰
pm2 start dist/app.js --name "tore-blockchain-server" --env production

# PM2 ì„¤ì • íŒŒì¼
# ecosystem.config.js
module.exports = {
  apps: [{
    name: 'tore-blockchain-server',
    script: 'dist/app.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_file: './logs/combined.log',
    time: true
  }]
};
```

### í—¬ìŠ¤ ì²´í¬

```typescript
// src/routes/health.ts
export const healthCheck = async (req: Request, res: Response) => {
  try {
    const checks = {
      server: 'ok',
      database: 'ok',
      blockchain: 'ok',
      timestamp: new Date().toISOString()
    };
    
    // ë¸”ë¡ì²´ì¸ ì—°ê²° í™•ì¸
    try {
      await getContract();
    } catch (error) {
      checks.blockchain = 'error';
    }
    
    // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í™•ì¸ (í–¥í›„ í™•ì¥)
    // try {
    //   await db.ping();
    // } catch (error) {
    //   checks.database = 'error';
    // }
    
    const status = Object.values(checks).every(check => check === 'ok') ? 200 : 503;
    
    res.status(status).json({
      success: status === 200,
      data: checks
    });
  } catch (error) {
    res.status(503).json({
      success: false,
      error: 'Health check failed'
    });
  }
};
```

### ë°±ì—… ë° ë³µêµ¬

```bash
# ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œ ë°±ì—…
echo "CONTRACT_ADDRESS=0x..." >> contracts_backup.txt
echo "TORE_TOKEN_ADDRESS=0x..." >> contracts_backup.txt
echo "TORE_EXCHANGE_ADDRESS=0x..." >> contracts_backup.txt

# í™˜ê²½ ë³€ìˆ˜ ë°±ì—…
cp .env .env.backup

# ë¡œê·¸ íŒŒì¼ ë¡œí…Œì´ì…˜
logrotate /etc/logrotate.d/tore-blockchain-server
```

---

## ğŸ“ˆ í™•ì¥ì„± ê³ ë ¤ì‚¬í•­

### ìˆ˜í‰ í™•ì¥

```typescript
// src/utils/loadBalancer.ts
export class LoadBalancer {
  private servers = [
    'http://server1:3000',
    'http://server2:3000',
    'http://server3:3000'
  ];
  
  private currentIndex = 0;
  
  getNextServer(): string {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }
  
  async distributeRequest(endpoint: string, data: any) {
    const server = this.getNextServer();
    const response = await fetch(`${server}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  }
}
```

### ë°ì´í„°ë² ì´ìŠ¤ í™•ì¥

```typescript
// src/database/sharding.ts
export class DatabaseSharding {
  private shards = [
    { id: 0, connection: 'shard0_connection' },
    { id: 1, connection: 'shard1_connection' },
    { id: 2, connection: 'shard2_connection' }
  ];
  
  getShard(address: string): number {
    // ì£¼ì†Œ ê¸°ë°˜ ìƒ¤ë“œ ê²°ì •
    const hash = this.hashAddress(address);
    return hash % this.shards.length;
  }
  
  private hashAddress(address: string): number {
    let hash = 0;
    for (let i = 0; i < address.length; i++) {
      const char = address.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 32ë¹„íŠ¸ ì •ìˆ˜ë¡œ ë³€í™˜
    }
    return Math.abs(hash);
  }
}
```

### ìºì‹œ í™•ì¥

```typescript
// src/utils/redis.ts
import Redis from 'ioredis';

export class RedisCache {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3
    });
  }
  
  async set(key: string, value: any, ttl: number = 300) {
    await this.redis.setex(key, ttl, JSON.stringify(value));
  }
  
  async get(key: string): Promise<any | null> {
    const value = await this.redis.get(key);
    return value ? JSON.parse(value) : null;
  }
  
  async del(key: string) {
    await this.redis.del(key);
  }
}
```

---

## ğŸ“‹ ë§ˆë¬´ë¦¬

ì´ì œ ToreBlockChainServerì˜ ì „ì²´ ì‹œìŠ¤í…œì„ ì™„ì „íˆ ì´í•´í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

**ì™„ì„±ëœ ì‹œìŠ¤í…œ êµ¬ì„± ìš”ì†Œ:**

1. **NFT ê´€ë¦¬ ì‹œìŠ¤í…œ** (GameItem ì»¨íŠ¸ë™íŠ¸)
2. **TORE í† í° ì‹œìŠ¤í…œ** (ToreToken ì»¨íŠ¸ë™íŠ¸)
3. **NFT-TORE ê±°ë˜ì†Œ** (ToreExchange ì»¨íŠ¸ë™íŠ¸)
4. **í†µí•© ë°±ì—”ë“œ API** (Express ì„œë²„)
5. **í†µí•© í”„ë¡ íŠ¸ì—”ë“œ** (ì›¹ ì¸í„°í˜ì´ìŠ¤)
6. **ë³´ì•ˆ ë° ìµœì í™”** (ì¸ì¦, ìºì‹±, ëª¨ë‹ˆí„°ë§)

**ì£¼ìš” íŠ¹ì§•:**
- **ì™„ì „í•œ í†µí•©**: NFT, í† í°, ê±°ë˜ì†Œê°€ í•˜ë‚˜ì˜ ì‹œìŠ¤í…œìœ¼ë¡œ í†µí•©
- **í™•ì¥ ê°€ëŠ¥**: ëª¨ë“ˆí™”ëœ êµ¬ì¡°ë¡œ ê¸°ëŠ¥ ì¶”ê°€ ìš©ì´
- **ë³´ì•ˆ ê°•í™”**: ë‹¤ì¸µ ë³´ì•ˆ ì‹œìŠ¤í…œ êµ¬í˜„
- **ì„±ëŠ¥ ìµœì í™”**: ìºì‹±, ë°°ì¹˜ ì²˜ë¦¬, ëª¨ë‹ˆí„°ë§
- **ìš´ì˜ ì¤€ë¹„**: í”„ë¡œë•ì…˜ ë°°í¬ ë° ìš´ì˜ ë„êµ¬

**ë‹¤ìŒ ë‹¨ê³„:**
- ì‹¤ì œ í”„ë¡œì íŠ¸ì— ì ìš©í•´ë³´ì„¸ìš”
- ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì¶”ê°€í•´ë³´ì„¸ìš”
- ë‹¤ë¥¸ ë¸”ë¡ì²´ì¸ ë„¤íŠ¸ì›Œí¬ì— ë°°í¬í•´ë³´ì„¸ìš”
- ì‹¤ì œ ì„œë¹„ìŠ¤ë¡œ ë°œì „ì‹œì¼œë³´ì„¸ìš”

**ì„±ê³µì ì¸ ë¸”ë¡ì²´ì¸ ê°œë°œì„ ì‘ì›í•©ë‹ˆë‹¤! ğŸš€**
