# NFT ë¸”ë¡ì²´ì¸ í”„ë¡œì íŠ¸ ì™„ì „ ê°€ì´ë“œ - 9í¸: ì‹¤í–‰ íë¦„ ë° ì „ì²´ ë™ì‘ ì›ë¦¬

## ğŸ“š ëª©ì°¨
1. [ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#ì „ì²´-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
2. [NFT ìƒì„± íë¦„](#nft-ìƒì„±-íë¦„)
3. [NFT ì „ì†¡ íë¦„](#nft-ì „ì†¡-íë¦„)
4. [NFT ì¡°íšŒ íë¦„](#nft-ì¡°íšŒ-íë¦„)
5. [ì¸ì¦ íë¦„](#ì¸ì¦-íë¦„)
6. [ì—ëŸ¬ ì²˜ë¦¬ íë¦„](#ì—ëŸ¬-ì²˜ë¦¬-íë¦„)
7. [ë°ì´í„° íë¦„](#ë°ì´í„°-íë¦„)

---

## ğŸ— ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ì‹œìŠ¤í…œ êµ¬ì„±ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ì›¹ ë¸Œë¼ìš°ì €    â”‚    â”‚   Express ì„œë²„   â”‚    â”‚  Avalanche ë¸”ë¡ì²´ì¸ â”‚
â”‚   (í”„ë¡ íŠ¸ì—”ë“œ)   â”‚â—„â”€â”€â–ºâ”‚   (ë°±ì—”ë“œ)      â”‚â—„â”€â”€â–ºâ”‚   (ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â”‚                       â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚ MetaMaskâ”‚            â”‚ NFT API â”‚            â”‚GameItem â”‚
    â”‚  ì§€ê°‘   â”‚            â”‚ ì»¨íŠ¸ë¡¤ëŸ¬â”‚            â”‚ ì»¨íŠ¸ë™íŠ¸â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì»´í¬ë„ŒíŠ¸ ì—­í• 

#### 1. ì›¹ ë¸Œë¼ìš°ì € (í”„ë¡ íŠ¸ì—”ë“œ)
- **ì—­í• **: ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ì œê³µ
- **ê¸°ëŠ¥**: í¼ ì…ë ¥, ê²°ê³¼ í‘œì‹œ, MetaMask ì—°ë™
- **ê¸°ìˆ **: HTML, CSS, JavaScript, Ethers.js

#### 2. Express ì„œë²„ (ë°±ì—”ë“œ)
- **ì—­í• **: API ì„œë²„ ë° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì²˜ë¦¬
- **ê¸°ëŠ¥**: ìš”ì²­ ì²˜ë¦¬, ì¸ì¦, ë¸”ë¡ì²´ì¸ ìƒí˜¸ì‘ìš©
- **ê¸°ìˆ **: Node.js, TypeScript, Express.js

#### 3. Avalanche ë¸”ë¡ì²´ì¸
- **ì—­í• **: ë°ì´í„° ì €ì¥ ë° ê²€ì¦
- **ê¸°ëŠ¥**: NFT ìƒì„±, ì „ì†¡, ì‚­ì œ, ì¡°íšŒ
- **ê¸°ìˆ **: Solidity, Smart Contract

#### 4. MetaMask ì§€ê°‘
- **ì—­í• **: ì‚¬ìš©ì ì§€ê°‘ ë° íŠ¸ëœì­ì…˜ ìŠ¹ì¸
- **ê¸°ëŠ¥**: ì§€ê°‘ ì—°ê²°, íŠ¸ëœì­ì…˜ ì„œëª…, NFT í‘œì‹œ
- **ê¸°ìˆ **: Web3 Provider, Wallet API

---

## ğŸ¨ NFT ìƒì„± íë¦„

### ì „ì²´ íë¦„ë„

```
ì‚¬ìš©ì ì…ë ¥ â†’ ì›¹ í˜ì´ì§€ â†’ Express ì„œë²„ â†’ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ â†’ ë¸”ë¡ì²´ì¸
     â†‘                                                      â†“
ì§€ê°‘ì— ì¶”ê°€ â† MetaMask â† íŠ¸ëœì­ì…˜ ì™„ë£Œ â† ë¸”ë¡ ìƒì„± â† íŠ¸ëœì­ì…˜ ì²˜ë¦¬
```

### ìƒì„¸ ì‹¤í–‰ íë¦„

#### 1ë‹¨ê³„: ì‚¬ìš©ì ì…ë ¥
```javascript
// ì‚¬ìš©ìê°€ ì›¹ í˜ì´ì§€ì—ì„œ ì…ë ¥
const to = "0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6";
const tokenURI = "https://ipfs.io/ipfs/QmYourMetadataHash";
```

#### 2ë‹¨ê³„: í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬
```javascript
// public/js/nft.js
async function handleMint(event) {
    event.preventDefault();
    
    // ì…ë ¥ê°’ ê²€ì¦
    const validation = this.validateFormData({ to, tokenURI }, validationRules);
    if (!validation.isValid) {
        this.showStatus(validation.errors.join(', '), 'error');
        return;
    }
    
    // API í˜¸ì¶œ
    const mintResult = await this.createNFT(to, tokenURI);
}
```

#### 3ë‹¨ê³„: API ìš”ì²­
```javascript
async function createNFT(to, tokenURI) {
    const response = await fetch('/api/nft/mint', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ to, tokenURI })
    });
    
    return await response.json();
}
```

#### 4ë‹¨ê³„: ë°±ì—”ë“œ ì²˜ë¦¬
```typescript
// src/controllers/nftController.ts
export async function mintNftController(req: Request, res: Response) {
    try {
        // ì…ë ¥ê°’ ê²€ì¦
        const { to, tokenURI } = req.body;
        if (!to || !tokenURI) {
            return res.status(400).json({ error: "Invalid input" });
        }
        
        // ë¸”ë¡ì²´ì¸ ì»¨íŠ¸ë™íŠ¸ ì—°ê²°
        const contract = await getContract();
        
        // NFT ë¯¼íŒ… íŠ¸ëœì­ì…˜ ì‹¤í–‰
        const tx = await contract.mint(to, tokenURI);
        
        // íŠ¸ëœì­ì…˜ ì™„ë£Œ ëŒ€ê¸°
        const receipt = await tx.wait();
        
        // ê²°ê³¼ ë°˜í™˜
        res.json({ 
            txHash: receipt?.hash ?? tx.hash,
            tokenId: tokenId,
            contractAddress: process.env.CONTRACT_ADDRESS
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
}
```

#### 5ë‹¨ê³„: ë¸”ë¡ì²´ì¸ ì²˜ë¦¬
```solidity
// contracts/GameItem.sol
function mint(address to, string memory tokenURI_) external onlyOwner returns (uint256 tokenId) {
    tokenId = ++_nextTokenId;        // í† í° ID í• ë‹¹
    _safeMint(to, tokenId);          // NFT ìƒì„±
    _setTokenURI(tokenId, tokenURI_); // URI ì„¤ì •
}
```

#### 6ë‹¨ê³„: íŠ¸ëœì­ì…˜ ì™„ë£Œ
```typescript
// íŠ¸ëœì­ì…˜ ì˜ìˆ˜ì¦ì—ì„œ ì´ë²¤íŠ¸ íŒŒì‹±
let tokenId: number | null = null;
if (receipt?.logs) {
    for (const log of receipt.logs) {
        const parsedLog = contract.interface.parseLog(log);
        if (parsedLog?.name === 'Transfer') {
            tokenId = Number(parsedLog.args[2]);
            break;
        }
    }
}
```

#### 7ë‹¨ê³„: ì§€ê°‘ì— NFT ì¶”ê°€
```javascript
// MetaMaskì— NFT ìë™ ì¶”ê°€
await window.ethereum.request({
    method: 'wallet_watchAsset',
    params: {
        type: 'ERC721',
        options: {
            address: contractAddress,
            tokenId: tokenId.toString(),
        },
    },
});
```

---

## ğŸ”„ NFT ì „ì†¡ íë¦„

### ì „ì²´ íë¦„ë„

```
ì‚¬ìš©ì ì…ë ¥ â†’ ì›¹ í˜ì´ì§€ â†’ Express ì„œë²„ â†’ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ â†’ ë¸”ë¡ì²´ì¸
     â†‘                                                      â†“
ê²°ê³¼ í‘œì‹œ â† JSON ì‘ë‹µ â† íŠ¸ëœì­ì…˜ ì™„ë£Œ â† ë¸”ë¡ ìƒì„± â† íŠ¸ëœì­ì…˜ ì²˜ë¦¬
```

### ìƒì„¸ ì‹¤í–‰ íë¦„

#### 1ë‹¨ê³„: ì‚¬ìš©ì ì…ë ¥
```javascript
const from = "0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6";
const to = "0x8ba1f109551bD432803012645Hac136c";
const tokenId = 1;
```

#### 2ë‹¨ê³„: í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬
```javascript
async function handleTransfer(event) {
    event.preventDefault();
    
    // ì…ë ¥ê°’ ê²€ì¦
    if (from.toLowerCase() === to.toLowerCase()) {
        this.showStatus('ë³´ë‚´ëŠ” ì£¼ì†Œì™€ ë°›ëŠ” ì£¼ì†Œê°€ ê°™ìŠµë‹ˆë‹¤.', 'error');
        return;
    }
    
    // API í˜¸ì¶œ
    const transferResult = await this.transferNFT(from, to, tokenId);
}
```

#### 3ë‹¨ê³„: API ìš”ì²­
```javascript
async function transferNFT(from, to, tokenId) {
    const response = await fetch('/api/nft/transfer', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ from, to, tokenId })
    });
    
    return await response.json();
}
```

#### 4ë‹¨ê³„: ë°±ì—”ë“œ ì²˜ë¦¬
```typescript
export async function transferNftController(req: Request, res: Response) {
    try {
        const { from, to, tokenId } = req.body;
        
        // ì…ë ¥ê°’ ê²€ì¦
        if (!from || !to || !tokenId) {
            return res.status(400).json({ error: "Invalid input" });
        }
        
        // ë¸”ë¡ì²´ì¸ ì»¨íŠ¸ë™íŠ¸ ì—°ê²°
        const contract = await getContract();
        
        // NFT ì „ì†¡ íŠ¸ëœì­ì…˜ ì‹¤í–‰
        const tx = await contract.transferFrom(from, to, BigInt(tokenId));
        
        // íŠ¸ëœì­ì…˜ ì™„ë£Œ ëŒ€ê¸°
        const receipt = await tx.wait();
        
        // ê²°ê³¼ ë°˜í™˜
        res.json({ txHash: receipt?.hash ?? tx.hash });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
}
```

#### 5ë‹¨ê³„: ë¸”ë¡ì²´ì¸ ì²˜ë¦¬
```solidity
// ERC721 í‘œì¤€ì˜ transferFrom í•¨ìˆ˜
function transferFrom(address from, address to, uint256 tokenId) public virtual override {
    _transfer(from, to, tokenId);
}
```

---

## ğŸ” NFT ì¡°íšŒ íë¦„

### ì „ì²´ íë¦„ë„

```
ì‚¬ìš©ì ìš”ì²­ â†’ ì›¹ í˜ì´ì§€ â†’ Express ì„œë²„ â†’ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ â†’ ë¸”ë¡ì²´ì¸
     â†‘                                                      â†“
ê²°ê³¼ í‘œì‹œ â† JSON ì‘ë‹µ â† ë°ì´í„° ì¡°íšŒ â† ë¸”ë¡ì²´ì¸ ì¡°íšŒ â† ì´ë²¤íŠ¸ ë¡œê·¸
```

### ìƒì„¸ ì‹¤í–‰ íë¦„

#### 1ë‹¨ê³„: ì‚¬ìš©ì ìš”ì²­
```javascript
const tokenId = 1; // ì¡°íšŒí•  NFT ID
```

#### 2ë‹¨ê³„: í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬
```javascript
async function handleInfo(event) {
    event.preventDefault();
    
    const tokenId = this.elements.infoTokenId.value.trim();
    
    // ì…ë ¥ê°’ ê²€ì¦
    const tokenIdNum = Number(tokenId);
    if (!Number.isInteger(tokenIdNum) || tokenIdNum < 0) {
        this.showStatus('ì˜¬ë°”ë¥¸ í† í° IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
        return;
    }
    
    // API í˜¸ì¶œ
    const infoResult = await this.getNFTInfo(tokenId);
}
```

#### 3ë‹¨ê³„: API ìš”ì²­
```javascript
async function getNFTInfo(tokenId) {
    const response = await fetch(`/api/nft/${tokenId}`);
    return await response.json();
}
```

#### 4ë‹¨ê³„: ë°±ì—”ë“œ ì²˜ë¦¬
```typescript
export async function getNftController(req: Request, res: Response) {
    try {
        const { tokenId } = req.params;
        
        // ì…ë ¥ê°’ ê²€ì¦
        const numeric = Number(tokenId);
        if (!Number.isInteger(numeric) || numeric < 0) {
            return res.status(400).json({ error: "Invalid tokenId" });
        }
        
        // ë¸”ë¡ì²´ì¸ ì»¨íŠ¸ë™íŠ¸ ì—°ê²°
        const contract = await getContract();
        
        // NFT ì •ë³´ ì¡°íšŒ (ê°€ìŠ¤ ë¹„ìš© ì—†ìŒ - view í•¨ìˆ˜)
        const [owner, tokenURI] = await Promise.all([
            contract.ownerOf(BigInt(tokenId)),
            contract.tokenURI(BigInt(tokenId))
        ]);
        
        // ê²°ê³¼ ë°˜í™˜
        res.json({ 
            owner: owner,
            tokenURI: tokenURI
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
}
```

#### 5ë‹¨ê³„: ë¸”ë¡ì²´ì¸ ì¡°íšŒ
```solidity
// ERC721 í‘œì¤€ì˜ view í•¨ìˆ˜ë“¤
function ownerOf(uint256 tokenId) public view virtual override returns (address) {
    return _ownerOf(tokenId);
}

function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    return _tokenURI(tokenId);
}
```

---

## ğŸ” ì¸ì¦ íë¦„

### JWT ì¸ì¦ íë¦„

#### 1ë‹¨ê³„: ë¡œê·¸ì¸ ìš”ì²­
```javascript
const loginData = {
    username: "admin",
    password: "password"
};
```

#### 2ë‹¨ê³„: ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
```typescript
export async function loginController(req: Request, res: Response) {
    try {
        const { username, password } = req.body;
        
        // ì‚¬ìš©ì ê²€ìƒ‰
        const user = users.find(u => u.username === username);
        
        if (!user) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        // ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ (bcrypt.compare)
        const isPasswordValid = await bcrypt.compare(password, user.password);
        
        if (!isPasswordValid) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        // JWT í† í° ìƒì„±
        const tokens = generateTokenPair({
            userId: user.id,
            username: user.username,
            email: user.email,
            role: user.role
        });
        
        res.json({
            success: true,
            ...tokens,
            user: { id: user.id, username: user.username, email: user.email, role: user.role }
        });
    } catch (error) {
        res.status(500).json({ error: 'Login failed' });
    }
}
```

#### 3ë‹¨ê³„: í† í° ìƒì„±
```typescript
export function generateTokenPair(payload: JWTPayload) {
    const accessToken = jwt.sign(payload, process.env.JWT_ACCESS_SECRET!, {
        expiresIn: '15m'  // 15ë¶„
    });
    
    const refreshToken = jwt.sign(payload, process.env.JWT_REFRESH_SECRET!, {
        expiresIn: '7d'   // 7ì¼
    });
    
    return { accessToken, refreshToken, expiresIn: 900 };
}
```

#### 4ë‹¨ê³„: í† í° ì‚¬ìš©
```javascript
// í”„ë¡ íŠ¸ì—”ë“œì—ì„œ í† í° ì €ì¥
localStorage.setItem('accessToken', response.accessToken);
localStorage.setItem('refreshToken', response.refreshToken);

// API ìš”ì²­ ì‹œ í† í° í¬í•¨
const response = await fetch('/api/nft/mint', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + localStorage.getItem('accessToken')
    },
    body: JSON.stringify({ to, tokenURI })
});
```

#### 5ë‹¨ê³„: í† í° ê²€ì¦
```typescript
export function authenticateJWT(req: AuthenticatedRequest, res: Response, next: NextFunction) {
    try {
        const authHeader = req.headers.authorization;
        
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return res.status(401).json({ error: 'No token provided' });
        }
        
        const token = authHeader.substring(7);
        
        // JWT í† í° ê²€ì¦
        const decoded = jwt.verify(token, process.env.JWT_ACCESS_SECRET!) as any;
        
        // ì‚¬ìš©ì ì •ë³´ë¥¼ ìš”ì²­ ê°ì²´ì— ì¶”ê°€
        req.user = {
            userId: decoded.userId,
            username: decoded.username,
            email: decoded.email,
            role: decoded.role
        };
        
        next();
    } catch (error) {
        if (error instanceof jwt.TokenExpiredError) {
            return res.status(401).json({ error: 'Token expired' });
        } else {
            return res.status(401).json({ error: 'Invalid token' });
        }
    }
}
```

---

## âš ï¸ ì—ëŸ¬ ì²˜ë¦¬ íë¦„

### ì—ëŸ¬ ì²˜ë¦¬ ê³„ì¸µ

```
ì‚¬ìš©ì ì…ë ¥ â†’ í”„ë¡ íŠ¸ì—”ë“œ ê²€ì¦ â†’ ë°±ì—”ë“œ ê²€ì¦ â†’ ë¸”ë¡ì²´ì¸ ì²˜ë¦¬ â†’ ì—ëŸ¬ ì‘ë‹µ
     â†‘                                                              â†“
ì—ëŸ¬ í‘œì‹œ â† ì—ëŸ¬ ë©”ì‹œì§€ â† JSON ì‘ë‹µ â† ì—ëŸ¬ ì²˜ë¦¬ â† ì˜ˆì™¸ ë°œìƒ
```

### ìƒì„¸ ì—ëŸ¬ ì²˜ë¦¬ íë¦„

#### 1ë‹¨ê³„: í”„ë¡ íŠ¸ì—”ë“œ ê²€ì¦
```javascript
// ì…ë ¥ê°’ ê²€ì¦
const validation = this.validateFormData({ to, tokenURI }, validationRules);
if (!validation.isValid) {
    this.showStatus(validation.errors.join(', '), 'error');
    return;
}
```

#### 2ë‹¨ê³„: ë°±ì—”ë“œ ê²€ì¦
```typescript
// ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì…ë ¥ê°’ ê²€ì¦
if (!to || typeof to !== "string" || !/^0x[a-fA-F0-9]{40}$/.test(to)) {
    return res.status(400).json({ error: "Invalid 'to' address" });
}
```

#### 3ë‹¨ê³„: ë¸”ë¡ì²´ì¸ ì—ëŸ¬ ì²˜ë¦¬
```typescript
try {
    const tx = await contract.mint(to, tokenURI);
    const receipt = await tx.wait();
    res.json({ txHash: receipt?.hash ?? tx.hash });
} catch (err: any) {
    console.error('[mint] error:', err);
    return res.status(500).json({ error: err.message || "Mint failed" });
}
```

#### 4ë‹¨ê³„: ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬
```typescript
export function errorHandler(err: Error, req: Request, res: Response, next: NextFunction): void {
    console.error('[Error Handler]', err);
    
    let status = 500;
    let message = 'Internal server error';
    let code = 'INTERNAL_ERROR';
    
    if (err.name === 'ValidationError') {
        status = 400;
        message = 'Validation error';
        code = 'VALIDATION_ERROR';
    } else if (err.name === 'UnauthorizedError') {
        status = 401;
        message = 'Unauthorized';
        code = 'UNAUTHORIZED';
    }
    
    res.status(status).json({
        error: message,
        code: code,
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    });
}
```

---

## ğŸ“Š ë°ì´í„° íë¦„

### ë°ì´í„° íë¦„ë„

```
ì‚¬ìš©ì ì…ë ¥ â†’ í”„ë¡ íŠ¸ì—”ë“œ â†’ ë°±ì—”ë“œ â†’ ë¸”ë¡ì²´ì¸ â†’ ë°ì´í„°ë² ì´ìŠ¤
     â†‘                                                      â†“
ê²°ê³¼ í‘œì‹œ â† JSON ì‘ë‹µ â† ë°ì´í„° ì²˜ë¦¬ â† íŠ¸ëœì­ì…˜ ì™„ë£Œ â† ìƒíƒœ ì €ì¥
```

### ë°ì´í„° ë³€í™˜ ê³¼ì •

#### 1ë‹¨ê³„: ì‚¬ìš©ì ì…ë ¥
```javascript
// ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë°ì´í„°
const userInput = {
    to: "0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6",
    tokenURI: "https://ipfs.io/ipfs/QmYourMetadataHash"
};
```

#### 2ë‹¨ê³„: í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬
```javascript
// ì…ë ¥ê°’ ê²€ì¦ ë° ë³€í™˜
const validatedData = {
    to: userInput.to.toLowerCase(),
    tokenURI: userInput.tokenURI.trim()
};
```

#### 3ë‹¨ê³„: HTTP ìš”ì²­
```javascript
// JSONìœ¼ë¡œ ì§ë ¬í™”
const requestBody = JSON.stringify(validatedData);
```

#### 4ë‹¨ê³„: ë°±ì—”ë“œ ì²˜ë¦¬
```typescript
// JSON íŒŒì‹±
const { to, tokenURI } = req.body as { to: string; tokenURI: string };

// íƒ€ì… ë³€í™˜
const contract = await getContract();
```

#### 5ë‹¨ê³„: ë¸”ë¡ì²´ì¸ ì²˜ë¦¬
```solidity
// Solidity í•¨ìˆ˜ í˜¸ì¶œ
function mint(address to, string memory tokenURI_) external onlyOwner returns (uint256 tokenId) {
    tokenId = ++_nextTokenId;
    _safeMint(to, tokenId);
    _setTokenURI(tokenId, tokenURI_);
}
```

#### 6ë‹¨ê³„: ì‘ë‹µ ìƒì„±
```typescript
// ê²°ê³¼ ê°ì²´ ìƒì„±
const response = {
    txHash: receipt?.hash ?? tx.hash,
    tokenId: tokenId,
    contractAddress: process.env.CONTRACT_ADDRESS
};

// JSONìœ¼ë¡œ ì§ë ¬í™”
res.json(response);
```

#### 7ë‹¨ê³„: í”„ë¡ íŠ¸ì—”ë“œ í‘œì‹œ
```javascript
// ì‘ë‹µ ë°ì´í„° ì²˜ë¦¬
if (mintResult.success) {
    this.showStatus(`ë¯¼íŒ… ì„±ê³µ! í† í° ID: ${mintResult.tokenId}`, 'success');
    await this.addNFTToWallet(mintResult.contractAddress, mintResult.tokenId);
} else {
    this.showStatus('ë¯¼íŒ… ì‹¤íŒ¨: ' + mintResult.error, 'error');
}
```

---

## ğŸ“‹ ë‹¤ìŒ ë‹¨ê³„

ì´ì œ ì‹¤í–‰ íë¦„ê³¼ ì „ì²´ ë™ì‘ ì›ë¦¬ë¥¼ ì´í•´í–ˆìœ¼ë‹ˆ, ë§ˆì§€ë§‰ ê°€ì´ë“œì—ì„œëŠ” ë¬¸ì œ í•´ê²°ê³¼ FAQì— ëŒ€í•´ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

**ë‹¤ìŒ ê°€ì´ë“œ**: [ë¬¸ì œ í•´ê²° ë° FAQ](./NFT_BLOCKCHAIN_PROJECT_GUIDE_10_ë¬¸ì œí•´ê²°.md)

---

## ğŸ’¡ í•µì‹¬ ì •ë¦¬

1. **ì „ì²´ ì‹œìŠ¤í…œì€ ì›¹ ë¸Œë¼ìš°ì €, Express ì„œë²„, ë¸”ë¡ì²´ì¸ì´ ì—°ê²°ë˜ì–´ ì‘ë™í•©ë‹ˆë‹¤.**
2. **NFT ìƒì„±ì€ ì‚¬ìš©ì ì…ë ¥ë¶€í„° ë¸”ë¡ì²´ì¸ ì €ì¥ê¹Œì§€ ì—¬ëŸ¬ ë‹¨ê³„ë¥¼ ê±°ì¹©ë‹ˆë‹¤.**
3. **ì¸ì¦ ì‹œìŠ¤í…œì€ JWT í† í°ì„ í†µí•´ ì‚¬ìš©ì ì¸ì¦ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.**
4. **ì—ëŸ¬ ì²˜ë¦¬ëŠ” ê° ê³„ì¸µì—ì„œ ì ì ˆí•œ ê²€ì¦ê³¼ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.**
5. **ë°ì´í„°ëŠ” ì‚¬ìš©ì ì…ë ¥ë¶€í„° ë¸”ë¡ì²´ì¸ ì €ì¥ê¹Œì§€ ë³€í™˜ ê³¼ì •ì„ ê±°ì¹©ë‹ˆë‹¤.**
